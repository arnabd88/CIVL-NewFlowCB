Everything starts from here
Checking the command line = [Ljava.lang.String;@d716361
CIVL v1.7 of 2016-03-31 -- http://vsl.cis.udel.edu/civl
definedOptions = [-DKEY=VALUE
    macro definitions: <macro> or <macro>=<object>, -_CIVL or -_CIVL=BOOLEAN (default: true)
    Define _CIVL macro?, -analyze_abs or -analyze_abs=BOOLEAN (default: false)
    analyze abs calls? false by default, -ast or -ast=BOOLEAN (default: false)
    print the AST of the program, -checkDivisionByZero or -checkDivisionByZero=BOOLEAN (default: true)
    check division-by-zero?, -checkMemoryLeak or -checkMemoryLeak=BOOLEAN (default: true)
    check memory-leak errors?, -collectHeaps or -collectHeaps=BOOLEAN (default: true)
    collect heaps?, -collectOutput or -collectOutput=BOOLEAN (default: false)
    collect output?, -collectProcesses or -collectProcesses=BOOLEAN (default: true)
    collect processes?, -collectScopes or -collectScopes=BOOLEAN (default: true)
    collect dyscopes?, -deadlock=STRING (default: absolute)
    deadlock kind? (potential|absolute|none), -debug or -debug=BOOLEAN (default: false)
    debug mode: print very detailed information, -enablePrintf or -enablePrintf=BOOLEAN (default: true)
    enable printf function, -errorBound=INTEGER (default: 1)
    stop after finding this many errors, -errorStateEquiv=STRING (default: LOC)
    semantics for equivalent error states: (LOC|CALLSTACK|FULL), -gui or -gui=BOOLEAN (default: false)
    launch GUI? (under development, only works with replay), -guided or -guided=BOOLEAN
    user guided simulation; applies only to run, ignored
    for all other commands, -id=INTEGER (default: 0)
    ID number of trace to replay; applies only to replay command, -inputKEY=VALUE
    initialize input variable KEY to VALUE; applies only to run and verify, -link=STRING
    link a source file with the target program, -maxdepth=INTEGER (default: 2147483647)
    bound on search depth, -min or -min=BOOLEAN (default: false)
    search for minimal counterexample, -mpiContract or -mpiContract=BOOLEAN (default: false)
    enable contracts for MPI mode, -ompLoopDecomp=STRING (default: ROUND_ROBIN)
    loop decomposition strategy? (ALL|ROUND_ROBIN|RANDOM), -ompNoSimplify or -ompNoSimplify=BOOLEAN (default: false)
    don't simplify omp pragmas, -preproc or -preproc=BOOLEAN (default: false)
    show the preprocessing result?, -procBound=INTEGER (default: -1)
    bound on number of live processes (no bound if negative), -quiet or -quiet=BOOLEAN (default: false)
    ignore output?, -random or -random=BOOLEAN
    select enabled transitions randomly; default for run,
    ignored for all other commands, -saveStates or -saveStates=BOOLEAN (default: true)
    save states during depth-first search, -seed=INTEGER
    set the random seed; applies only to run, -showAmpleSet or -showAmpleSet=BOOLEAN (default: false)
    print the ample set when it contains more than one processes, -showAmpleSetWtStates or -showAmpleSetWtStates=BOOLEAN (default: false)
    print ample set and state when ample set contains >1 processes, -showInputs or -showInputs=BOOLEAN (default: false)
    show input variables of my program?, -showMemoryUnits or -showMemoryUnits=BOOLEAN (default: false)
    print the impact/reachable memory units when the state contains more than one processes, -showModel or -showModel=BOOLEAN (default: false)
    print the model, -showPathCondition or -showPathCondition=BOOLEAN (default: false)
    show the path condition of each state?, -showProgram or -showProgram=BOOLEAN (default: false)
    show my program after transformations?, -showProverQueries or -showProverQueries=BOOLEAN (default: false)
    print theorem prover queries only, -showQueries or -showQueries=BOOLEAN (default: false)
    print all queries, -showSavedStates or -showSavedStates=BOOLEAN (default: false)
    print saved states only, -showStates or -showStates=BOOLEAN (default: false)
    print all states, -showTime or -showTime=BOOLEAN (default: false)
    print timings, -showTransitions or -showTransitions=BOOLEAN (default: false)
    print transitions, -showUnreached or -showUnreached=BOOLEAN (default: false)
    print the unreachable code, -simplify or -simplify=BOOLEAN (default: true)
    simplify states?, -solve or -solve=BOOLEAN (default: false)
    try to solve for concrete counterexample, -statelessPrintf or -statelessPrintf=BOOLEAN (default: true)
    prevent printf function modifying the file system, -strict or -strict=BOOLEAN (default: true)
    check strict functional equivalence?, -svcomp16 or -svcomp16=BOOLEAN (default: false)
    translate program for sv-comp 2016?, -sysIncludePath=STRING
    set the system include path, using : to separate multiple paths, -timeout=INTEGER (default: -1)
    time out in seconds, default is never time out, -trace=STRING
    filename of trace to replay, -unpreproc or -unpreproc=BOOLEAN (default: false)
    unpreprocess the source?, -userIncludePath=STRING
    set the user include path, using : to separate multiple paths, -verbose or -verbose=BOOLEAN (default: false)
    verbose mode, -web or -web=BOOLEAN (default: false)
    write output for web app?]
Name = main
Name = _heap
Name = _atomic_lock_var
Name = _X_count_var
Name = _Y_count_var
Name = $assert
Name = expr
Name = _heap
Name = $assume
Name = expr
Name = _heap
Name = B
Name = N
Name = N
Name = N
Name = B
Name = N
Name = a
Name = adderSeq
Name = p
Name = n
Name = _heap
Name = adderPar
Name = p
Name = n
Name = _heap
Name = _heap
Name = seq
Name = a
Name = N
Name = par
Name = a
Name = N
Name = seq
Name = par
Name = _heap
Name = s
Name = _heap
Name = i
Name = i
Name = n
Name = i
Name = i
Name = s
Name = s
Name = p
Name = i
Name = s
Name = _heap
Name = s
Name = worker
Name = i
Name = _heap
Name = _heap
Name = i
Name = _dom_size0
Name = _par_procs0
Name = _par_proc0
Name = _heap
Name = n
Name = domain
Name = $elaborate_domain
Name = _heap
Name = procs
Name = num
Name = $waitall
Name = _heap
Name = s
Name = _heap
Name = t
Name = t
Name = s
Name = t
Name = t
Name = p
Name = i
Name = s
Name = t
Name = i
Model = edu.udel.cis.vsl.civl.model.common.CommonModel@25fb8912
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 1)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 1)
PID = 0
ProcessState p = State of process 0 (call stack length = 1)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 1)
PID = 0
ProcessState p = State of process 0 (call stack length = 1)
PID = 0
Call-source = adderBad.cvl:10.0-21 "$assume(0<=N && N ... )"
ProcessState p = State of process 0 (call stack length = 1)
PID = 0
ProcessState p = State of process 0 (call stack length = 1)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 1)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
ProcessState p = State of process 0 (call stack length = 1)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 1)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Call-source = adderBad.cvl:34.18-26 "0 .. n-1"
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 1 (call stack length = 1)
PID = 1
Nswitch = 0
ProcessState p = State of process 1 (call stack length = 2)
PID = 1
PidInAtomic = -1
ProcessState p = State of process 2 (call stack length = 1)
PID = 2
Nswitch = 0
ProcessState p = State of process 2 (call stack length = 2)
PID = 2
PidInAtomic = -1
ProcessState p = State of process 3 (call stack length = 1)
PID = 3
Nswitch = 0
ProcessState p = State of process 3 (call stack length = 2)
PID = 3
PidInAtomic = -1
ProcessState p = State of process 4 (call stack length = 1)
PID = 4
Nswitch = 0
ProcessState p = State of process 4 (call stack length = 2)
PID = 4
PidInAtomic = -1
ProcessState p = State of process 5 (call stack length = 1)
PID = 5
Nswitch = 0
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
PidInAtomic = -1
ProcessState p = State of process 1 (call stack length = 2)
PID = 1
ProcessState p = State of process 2 (call stack length = 2)
PID = 2
ProcessState p = State of process 3 (call stack length = 2)
PID = 3
ProcessState p = State of process 4 (call stack length = 2)
PID = 4
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
Nswitch = 0
ProcessState p = State of process 1 (call stack length = 2)
PID = 1
PidInAtomic = -1
ProcessState p = State of process 1 (call stack length = 2)
PID = 1
Nswitch = 0
ProcessState p = State of process 1 (call stack length = 2)
PID = 1
PidInAtomic = -1
ProcessState p = State of process 1 (call stack length = 2)
PID = 1
ProcessState p = State of process 2 (call stack length = 2)
PID = 2
ProcessState p = State of process 3 (call stack length = 2)
PID = 3
ProcessState p = State of process 4 (call stack length = 2)
PID = 4
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
Nswitch = 0
ProcessState p = State of process 1 (call stack length = 2)
PID = 1
ProcessState p = State of process 1 (call stack length = 1)
PID = 1
PidInAtomic = -1
ProcessState p = State of process 2 (call stack length = 2)
PID = 2
ProcessState p = State of process 3 (call stack length = 2)
PID = 3
ProcessState p = State of process 4 (call stack length = 2)
PID = 4
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
Nswitch = 0
ProcessState p = State of process 2 (call stack length = 2)
PID = 2
PidInAtomic = -1
ProcessState p = State of process 2 (call stack length = 2)
PID = 2
Nswitch = 0
ProcessState p = State of process 2 (call stack length = 2)
PID = 2
PidInAtomic = -1
ProcessState p = State of process 2 (call stack length = 2)
PID = 2
ProcessState p = State of process 3 (call stack length = 2)
PID = 3
ProcessState p = State of process 4 (call stack length = 2)
PID = 4
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
Nswitch = 0
ProcessState p = State of process 2 (call stack length = 2)
PID = 2
ProcessState p = State of process 2 (call stack length = 1)
PID = 2
PidInAtomic = -1
ProcessState p = State of process 3 (call stack length = 2)
PID = 3
ProcessState p = State of process 4 (call stack length = 2)
PID = 4
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
Nswitch = 0
ProcessState p = State of process 3 (call stack length = 2)
PID = 3
PidInAtomic = -1
ProcessState p = State of process 3 (call stack length = 2)
PID = 3
Nswitch = 0
ProcessState p = State of process 3 (call stack length = 2)
PID = 3
PidInAtomic = -1
ProcessState p = State of process 3 (call stack length = 2)
PID = 3
ProcessState p = State of process 4 (call stack length = 2)
PID = 4
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
Nswitch = 0
ProcessState p = State of process 3 (call stack length = 2)
PID = 3
ProcessState p = State of process 3 (call stack length = 1)
PID = 3
PidInAtomic = -1
ProcessState p = State of process 4 (call stack length = 2)
PID = 4
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
Nswitch = 0
ProcessState p = State of process 4 (call stack length = 2)
PID = 4
PidInAtomic = -1
ProcessState p = State of process 4 (call stack length = 2)
PID = 4
Nswitch = 0
ProcessState p = State of process 4 (call stack length = 2)
PID = 4
PidInAtomic = -1
ProcessState p = State of process 4 (call stack length = 2)
PID = 4
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
Nswitch = 0
ProcessState p = State of process 4 (call stack length = 2)
PID = 4
ProcessState p = State of process 4 (call stack length = 1)
PID = 4
PidInAtomic = -1
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
Nswitch = 0
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
PidInAtomic = -1
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
Nswitch = 0
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
PidInAtomic = -1
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
Nswitch = 0
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
ProcessState p = State of process 5 (call stack length = 1)
PID = 5
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Call-source = adderBad.cvl:35.13-14 ";"
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 1)
PID = 0
Call-source = adderBad.cvl:43.2-21 "$assert(seq == par)"
ProcessState p = State of process 0 (call stack length = 1)
PID = 0
PidInAtomic = -1
Nswitch = 0
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
PidInAtomic = -1
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
Nswitch = 0
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
PidInAtomic = -1
ProcessState p = State of process 4 (call stack length = 2)
PID = 4
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
Nswitch = 0
ProcessState p = State of process 4 (call stack length = 2)
PID = 4
ProcessState p = State of process 4 (call stack length = 1)
PID = 4
PidInAtomic = -1
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
Nswitch = 0
ProcessState p = State of process 5 (call stack length = 2)
PID = 5
ProcessState p = State of process 5 (call stack length = 1)
PID = 5
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Call-source = adderBad.cvl:35.13-14 ";"
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
PidInAtomic = -1
ProcessState p = State of process 0 (call stack length = 2)
PID = 0
Nswitch = 0
ProcessState p = State of process 0 (call stack length = 1)
PID = 0
Call-source = adderBad.cvl:43.2-21 "$assert(seq == par)"

Violation 0 encountered at depth 37:
CIVL execution violation in p0(id=0) (kind: ASSERTION_VIOLATION, certainty: PROVEABLE)
at adderBad.cvl:43.2-21 "$assert(seq == par)":

Assertion: (seq==par)
        -> X_a[1]+X_a[2]+X_a[3]+X_a[4]+X_a[0]==X_a[1]+X_a[2]+X_a[4]+X_a[0]
        -> (X_a[1]+X_a[2]+X_a[3]+X_a[4]+X_a[0])==(X_a[1]+X_a[2]+X_a[4]+X_a[0])
        -> 0==X_a[3]

Input:
  B=5
  N=5
  a=X_a
Context:
  true
Call stacks:
process p0 (id=0):
  main at adderBad.cvl:43.2-9 "$assert"

Logging new entry 0, writing trace to CIVLREP/adderBad_0.trace
Terminating search after finding 1 violation.

=== Command ===
civl verify adderBad.cvl 

=== Stats ===
   time (s)            : 4.37
   memory (bytes)      : 28753920
   max process count   : 6
   states              : 72
   states saved        : 43
   state matches       : 0
   transitions         : 72
   trace steps         : 42
   valid calls         : 1565
   provers             : z3, cvc3
   prover calls        : 22

=== Result ===
The program MAY NOT be correct.  See CIVLREP/adderBad_log.txt
Everything ends in here
